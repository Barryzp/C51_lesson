C51 COMPILER V9.54   MATRIX_KEYBOARD                                                       01/22/2026 16:04:28 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MATRIX_KEYBOARD
OBJECT MODULE PLACED IN .\Objects\matrix_keyboard.obj
COMPILER INVOKED BY: F:\program_files\C51V5\C51\BIN\C51.EXE matrix_keyboard.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEN
                    -D PRINT(.\Listings\matrix_keyboard.lst) TABS(2) OBJECT(.\Objects\matrix_keyboard.obj)

line level    source

   1          #include "matrix_keyboard.h"
   2          
   3          // Placeholder function for matrix keyboard scanning
   4          unsigned char matrix_key_scan() {
   5   1      
   6   1          unsigned char key = 0; // No key pressed
   7   1      
   8   1          // 都设置为高电平
   9   1          P1 = 0xff; // Set all rows high
  10   1      
  11   1          P1_3 = 0;  //第一列设置为低电平，检测第一列按键的按下信号
  12   1          if (P1_7 == 0) //检测第一行按键
  13   1          {
  14   2              delay_for_ms(20); //消抖
  15   2              while (P1_7 == 0); //等待按键释放
  16   2              delay_for_ms(20); //消抖
  17   2              key = 1;
  18   2          }
  19   1          else if (P1_6 == 0) //检测第二行按键
  20   1          {
  21   2              delay_for_ms(20); //消抖
  22   2              while (P1_6 == 0); //等待按键释放
  23   2              delay_for_ms(20); //消抖
  24   2              key = 5;
  25   2          }
  26   1          else if (P1_5 == 0) //检测第三行按键
  27   1          {
  28   2              delay_for_ms(20); //消抖
  29   2              while (P1_5 == 0); //等待按键释放
  30   2              delay_for_ms(20); //消抖
  31   2              key = 9;
  32   2          }
  33   1          else if (P1_4 == 0) //检测第四行按键
  34   1          {
  35   2              delay_for_ms(20); //消抖
  36   2              while (P1_4 == 0); //等待按键释放
  37   2              delay_for_ms(20); //消抖
  38   2              key = 13;
  39   2          }
  40   1          
  41   1          // 都设置为高电平
  42   1          P1 = 0xff; // Set all rows high
  43   1          P1_2 = 0;  //第二列设置为低电平，检测第二列按键的按下信号
  44   1          if (P1_7 == 0) //检测第一行按键
  45   1          {
  46   2              delay_for_ms(20); //消抖
  47   2              while (P1_7 == 0); //等待按键释放
  48   2              delay_for_ms(20); //消抖
  49   2              key = 2;
  50   2          }
  51   1          else if (P1_6 == 0) //检测第二行按键
  52   1          {
  53   2              delay_for_ms(20); //消抖
  54   2              while (P1_6 == 0); //等待按键释放
C51 COMPILER V9.54   MATRIX_KEYBOARD                                                       01/22/2026 16:04:28 PAGE 2   

  55   2              delay_for_ms(20); //消抖
  56   2              key = 6;
  57   2          }
  58   1          else if (P1_5 == 0) //检测第三行按键
  59   1          {
  60   2              delay_for_ms(20); //消抖
  61   2              while (P1_5 == 0); //等待按键释放
  62   2              delay_for_ms(20); //消抖
  63   2              key = 10;
  64   2          }
  65   1          else if (P1_4 == 0) //检测第四行按键
  66   1          {
  67   2              delay_for_ms(20); //消抖
  68   2              while (P1_4 == 0); //等待按键释放
  69   2              delay_for_ms(20); //消抖
  70   2              key = 14;
  71   2          }
  72   1      
  73   1          // 都设置为高电平
  74   1          P1 = 0xff; // Set all rows high
  75   1          P1_1 = 0;  //第三列设置为低电平，检测第三列按键的按下信号
  76   1          if (P1_7 == 0) //检测第一行按键
  77   1          {
  78   2              delay_for_ms(20); //消抖
  79   2              while (P1_7 == 0); //等待按键释放
  80   2              delay_for_ms(20); //消抖
  81   2              key = 3;
  82   2          }
  83   1          else if (P1_6 == 0) //检测第二行按键
  84   1          {
  85   2              delay_for_ms(20); //消抖
  86   2              while (P1_6 == 0); //等待按键释放
  87   2              delay_for_ms(20); //消抖
  88   2              key = 7;
  89   2          }
  90   1          else if (P1_5 == 0) //检测第三行按键
  91   1          {
  92   2              delay_for_ms(20); //消抖
  93   2              while (P1_5 == 0); //等待按键释放
  94   2              delay_for_ms(20); //消抖
  95   2              key = 11;
  96   2          }
  97   1          else if (P1_4 == 0) //检测第四行按键
  98   1          {
  99   2              delay_for_ms(20); //消抖
 100   2              while (P1_4 == 0); //等待按键释放
 101   2              delay_for_ms(20); //消抖
 102   2              key = 15;
 103   2          }
 104   1      
 105   1          // 都设置为高电平
 106   1          P1 = 0xff; // Set all rows high
 107   1          P1_0 = 0;  //第四列设置为低电平，检测第四列按键的按下信号
 108   1          if (P1_7 == 0) //检测第一行按键
 109   1          {
 110   2              delay_for_ms(20); //消抖
 111   2              while (P1_7 == 0); //等待按键释放
 112   2              delay_for_ms(20); //消抖
 113   2              key = 4;
 114   2          }
 115   1          else if (P1_6 == 0) //检测第二行按键
 116   1          {
C51 COMPILER V9.54   MATRIX_KEYBOARD                                                       01/22/2026 16:04:28 PAGE 3   

 117   2              delay_for_ms(20); //消抖
 118   2              while (P1_6 == 0); //等待按键释放
 119   2              delay_for_ms(20); //消抖
 120   2              key = 8;
 121   2          }
 122   1          else if (P1_5 == 0) //检测第三行按键
 123   1          {
 124   2              delay_for_ms(20); //消抖
 125   2              while (P1_5 == 0); //等待按键释放
 126   2              delay_for_ms(20); //消抖
 127   2              key = 12;
 128   2          }
 129   1          else if (P1_4 == 0) //检测第四行按键
 130   1          {
 131   2              delay_for_ms(20); //消抖
 132   2              while (P1_4 == 0); //等待按键释放
 133   2              delay_for_ms(20); //消抖
 134   2              key = 16;
 135   2          }
 136   1      
 137   1          return key;
 138   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    543    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
